---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - app/config.py
  - app/db/database.py
  - app/db/models.py
  - app/services/storage.py
  - app/services/post_service.py
  - app/api/routes/posts.py
  - app/api/routes/packages.py
  - app/core/models/post_processor.py
  - alembic.ini
  - alembic/env.py
  - alembic/versions/001_initial_schema.py
autonomous: true
requirements: []
must_haves:
  truths:
    - "API starts inside Docker with PostgreSQL connection (no SQLite references remain)"
    - "Alembic migration creates post_packages and post_files tables with pgvector extension enabled"
    - "A file uploaded through MinIO storage service is retrievable with identical bytes"
    - "The in-memory _store dict is completely removed from the codebase"
    - "All existing API routes work against PostgreSQL instead of in-memory dict"
  artifacts:
    - path: "app/db/models.py"
      provides: "SQLAlchemy ORM models for post_packages and post_files"
      contains: "class PostPackage"
    - path: "app/services/storage.py"
      provides: "MinIO S3-compatible storage client"
      contains: "aiobotocore"
    - path: "app/config.py"
      provides: "Settings with PostgreSQL, Redis, MinIO, Celery config"
      contains: "minio_endpoint"
    - path: "alembic/versions/001_initial_schema.py"
      provides: "Initial PostgreSQL schema migration"
      contains: "post_packages"
    - path: "alembic.ini"
      provides: "Alembic configuration"
    - path: "alembic/env.py"
      provides: "Alembic environment with async engine support"
      contains: "asyncpg"
  key_links:
    - from: "app/db/models.py"
      to: "app/db/database.py"
      via: "Models inherit from Base"
      pattern: "class PostPackage\\(Base\\)"
    - from: "app/services/storage.py"
      to: "app/config.py"
      via: "Storage reads MinIO settings"
      pattern: "settings\\.minio_endpoint"
    - from: "app/services/post_service.py"
      to: "app/db/models.py"
      via: "Service queries ORM models"
      pattern: "PostPackage"
    - from: "alembic/env.py"
      to: "app/db/database.py"
      via: "Migration reads Base.metadata"
      pattern: "target_metadata"
---

<objective>
Replace the SQLite + in-memory `_store` backend with PostgreSQL (via SQLAlchemy async + Alembic) and add MinIO object storage for files. After this plan, all data flows through PostgreSQL and MinIO — no in-memory state, no SQLite.

Purpose: The scaffold currently uses an in-memory dict (`_store`) and SQLite. Both are disposable (user decision). This plan wires real persistence so that Plans 01-03 (ingestion) and all Phase 2+ work have a solid data layer.

Output: SQLAlchemy models, Alembic migration, MinIO storage service, rewritten routes/services — all running against Docker services from Plan 01-01.
</objective>

<execution_context>
@C:/Users/CameronCarson/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/CameronCarson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@app/config.py
@app/db/database.py
@app/services/post_service.py
@app/api/routes/posts.py
@app/core/models/post_processor.py
@app/main.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Settings, SQLAlchemy models, and Alembic migration</name>
  <files>
    app/config.py
    app/db/database.py
    app/db/models.py
    app/core/models/post_processor.py
    alembic.ini
    alembic/env.py
    alembic/script.mako
    alembic/versions/001_initial_schema.py
  </files>
  <action>
**Rewrite `app/config.py`** — extend Settings with all infrastructure config per research Pattern 5:
- `database_url: str = "postgresql+asyncpg://veripost:veripost@postgres:5432/veripost"` (replaces SQLite default)
- `redis_url: str = "redis://redis:6379/0"`
- `minio_endpoint: str = "minio:9000"`
- `minio_access_key: str = "veripost"`
- `minio_secret_key: str = "veripost123"`
- `minio_bucket: str = "veripost"`
- `minio_use_ssl: bool = False`
- `celery_broker_url: str = "redis://redis:6379/0"`
- `celery_result_backend: str = "redis://redis:6379/0"`
- Remove `corpus_dir` (not used — corpus is in MinIO now)

**Update `app/db/database.py`** — keep the same structure but ensure it works with asyncpg. The engine creation with `echo=settings.is_dev` stays. Add `pool_size=5, max_overflow=10` to engine for PostgreSQL connection pooling. Keep `init_db`, `get_db` functions. Import Base from here.

**Create `app/db/models.py`** — SQLAlchemy ORM models matching research Pattern 3 schema:

```python
class PostPackage(Base):
    __tablename__ = "post_packages"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(Text, nullable=False)  # derived from SRC filename
    machine_type = Column(Text, nullable=True)
    controller_type = Column(Text, nullable=True)
    platform = Column(Text, nullable=False, default="camworks")
    status = Column(Text, nullable=False, default="pending")
    error_message = Column(Text, nullable=True)  # friendly message
    error_detail = Column(Text, nullable=True)    # technical expandable detail
    file_count = Column(Integer, nullable=True)
    section_count = Column(Integer, nullable=True)
    minio_prefix = Column(Text, nullable=False)   # "packages/{id}/"
    created_at = Column(TIMESTAMP(timezone=True), server_default=func.now())
    updated_at = Column(TIMESTAMP(timezone=True), server_default=func.now(), onupdate=func.now())
    files = relationship("PostFile", back_populates="package", cascade="all, delete-orphan")

class PostFile(Base):
    __tablename__ = "post_files"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    package_id = Column(UUID(as_uuid=True), ForeignKey("post_packages.id", ondelete="CASCADE"), nullable=False)
    filename = Column(Text, nullable=False)
    file_extension = Column(Text, nullable=False)  # ".SRC", ".LIB", etc.
    minio_key = Column(Text, nullable=False)        # "packages/{pkg_id}/{filename}"
    size_bytes = Column(Integer, nullable=True)
    content_hash = Column(Text, nullable=True)       # SHA-256
    created_at = Column(TIMESTAMP(timezone=True), server_default=func.now())
    package = relationship("PostPackage", back_populates="files")
```

**Update `app/core/models/post_processor.py`** — keep as Pydantic response schemas but align field names with new ORM models. The existing `PostProcessorResponse` becomes `PackageResponse`. Add `PackageListResponse`, `FileResponse`. Remove `ParsedPost` (will be recreated in Phase 2 when parsing is real).

**Initialize Alembic:**
- Create `alembic.ini` with async PostgreSQL URL from `DATABASE_URL` env var
- Create `alembic/env.py` using async engine pattern (import `run_async_migrations`)
- Import `Base` from `app.db.database` and all models from `app.db.models` so metadata is populated
- Set `target_metadata = Base.metadata`
- Use `sqlalchemy.pool.NullPool` in the async migration runner (standard Alembic async pattern)

**Create initial migration `alembic/versions/001_initial_schema.py`:**
- `CREATE EXTENSION IF NOT EXISTS vector` (pgvector)
- Create `post_packages` table matching the ORM model
- Create `post_files` table matching the ORM model
- Add index on `post_files.package_id`
- Downgrade: drop both tables, drop extension
  </action>
  <verify>
With Docker services running (`docker compose up -d postgres`):
- Run `docker compose exec api alembic upgrade head` — migration completes without errors
- Run `docker compose exec postgres psql -U veripost -c "\dt"` — shows post_packages and post_files tables
- Run `docker compose exec postgres psql -U veripost -c "SELECT extname FROM pg_extension WHERE extname='vector'"` — shows vector extension
  </verify>
  <done>
PostgreSQL has post_packages and post_files tables. pgvector extension is installed. Alembic migration runs cleanly on startup. No SQLite references remain in config or database modules.
  </done>
</task>

<task type="auto">
  <name>Task 2: MinIO storage service and API route rewrite</name>
  <files>
    app/services/storage.py
    app/services/post_service.py
    app/api/routes/posts.py
    app/api/routes/packages.py
    app/main.py
  </files>
  <action>
**Create `app/services/storage.py`** — async MinIO client using aiobotocore per research Pattern 1 and Pitfall 3:

```python
class StorageService:
    async def init_bucket(self) -> None:
        """Create veripost bucket if it doesn't exist. Called at app startup."""

    async def upload_file(self, key: str, data: bytes, content_type: str = "application/octet-stream") -> None:
        """Upload bytes to MinIO under the given key."""

    async def download_file(self, key: str) -> bytes:
        """Download file bytes from MinIO by key."""

    async def list_files(self, prefix: str) -> list[str]:
        """List all keys under a prefix (e.g., packages/{id}/)."""

    async def delete_prefix(self, prefix: str) -> None:
        """Delete all objects under a prefix."""
```

Use `aiobotocore.session.get_session()` with `endpoint_url=f"http://{settings.minio_endpoint}"`, `use_ssl=False`. CRITICAL: use `http://` not `https://` per research Pitfall 3.

Create a module-level `storage` instance that routes/services import.

**Rewrite `app/services/post_service.py`** — completely replace `_store` with SQLAlchemy async queries:
- `list_packages(db: AsyncSession) -> list[PostPackage]` — `select(PostPackage).order_by(PostPackage.created_at.desc())`
- `get_package(db: AsyncSession, package_id: UUID) -> PostPackage | None` — by primary key with eager load of files
- `create_package(db: AsyncSession, name: str, minio_prefix: str, file_count: int) -> PostPackage` — insert new package record
- `update_package_status(db: AsyncSession, package_id: UUID, status: str, error_message: str | None, error_detail: str | None) -> None`
- Remove the `PostService` class (use module-level async functions — simpler, no state). Remove `_store` entirely. Remove `ingest_post` and `parse_post` methods (replaced by Celery task in Plan 01-03).

**Rewrite `app/api/routes/posts.py`** — update existing routes to use PostgreSQL:
- `GET /api/v1/posts` → list packages from DB, return PackageListResponse
- `GET /api/v1/posts/{package_id}` → get package from DB, return PackageResponse with files
- Keep the `POST /upload` route but make it a simple single-file placeholder (real ZIP upload comes in Plan 01-03). For now it creates a package record and stores the file in MinIO. This preserves API functionality during transition.

**Create `app/api/routes/packages.py`** — new router stub for package-level operations:
- `GET /api/v1/packages/{package_id}/files/{file_id}/download` — download a file from MinIO by its minio_key, return StreamingResponse with original bytes
- This route will be expanded in Plan 01-03 with ZIP upload

**Update `app/main.py`**:
- Add MinIO bucket initialization to lifespan startup: call `storage.init_bucket()`
- Register the packages router
- Remove `init_db()` call from lifespan (Alembic handles migrations at container startup before uvicorn starts)
  </action>
  <verify>
With all Docker services running (`docker compose up -d`):
- `curl http://localhost:8000/health` returns 200
- `curl http://localhost:8000/api/v1/posts` returns `{"packages": [], "count": 0}` (empty list from PostgreSQL, not _store)
- Upload a test file: `curl -X POST -F "file=@some_test_file" http://localhost:8000/api/v1/posts/upload` returns 200/201 with package_id
- Retrieve the package: `curl http://localhost:8000/api/v1/posts/{package_id}` returns package with file list
- Download the file: `curl http://localhost:8000/api/v1/packages/{package_id}/files/{file_id}/download` returns original bytes
- Verify MinIO has the file: check MinIO console at http://localhost:9001, navigate to veripost bucket, see packages/{id}/ prefix
- Run `grep -r "_store" app/` returns no matches (dict is gone)
  </verify>
  <done>
All API routes work against PostgreSQL and MinIO. Files uploaded through the API are stored in MinIO under packages/{id}/ prefix and retrievable with original bytes. The in-memory _store is completely eliminated. MinIO bucket is auto-created on startup.
  </done>
</task>

</tasks>

<verification>
1. `docker compose up` — API starts, connects to PostgreSQL, MinIO bucket initialized
2. No SQLite or _store references in codebase: `grep -rn "sqlite\|_store\|aiosqlite" app/` returns nothing
3. File round-trip: upload a file, download it, compare bytes
4. Database persistence: upload a file, `docker compose down && docker compose up`, file is still in MinIO and package record still in PostgreSQL
</verification>

<success_criteria>
- PostgreSQL is the only database backend (SQLite eliminated)
- MinIO is the only file storage backend (in-memory eliminated)
- All existing API routes work against the new backends
- Alembic migration runs automatically on container startup
- File upload → MinIO storage → download returns identical bytes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
